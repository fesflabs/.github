name: CD Centralizado (Deploy)

on:
  workflow_call:
    inputs:
      service_name:
        description: "Nome do serviÃ§o no docker-compose"
        required: true
        type: string
      project_type:
        description: "Tipo: 'backend' ou 'frontend'"
        required: true
        type: string
      working_directory:
        description: "DiretÃ³rio do docker-compose"
        required: false
        default: "."
        type: string
      runner_labels:
        description: "Labels do runner de deploy"
        required: true
        type: string
      environment_name:
        description: "Ambiente para carregar as variÃ¡veis (develop, homolog, prod)"
        required: true
        type: string
    secrets:
      REGISTRY_USERNAME:
        required: true
      REGISTRY_PASSWORD:
        required: true
      # Segredos da AplicaÃ§Ã£o (Definidos no Environment)
      PROD_DB_HOST:
        required: true
      PROD_DB_PORT:
        required: true
      PROD_DB_NAME:
        required: true
      PROD_DB_USER:
        required: true
      PROD_DB_PASSWORD:
        required: true
      PROD_LOG_LEVEL:
        required: true
      PROD_RELOAD:
        required: true
      JWT_SECRET:
        required: true
      MAIL_USERNAME:
        required: true
      MAIL_PASSWORD:
        required: true
      MAIL_FROM:
        required: true

jobs:

  # check-approvals:
  #   name: Verificar AprovaÃ§Ã£o
  #   runs-on: ubuntu-latest
  #   steps:
  #     - name: Verificar Reviews
  #       uses: actions/github-script@v7
  #       with:
  #         script: |
  #           if (!context.payload.pull_request) return;
  #           const { data: reviews } = await github.rest.pulls.listReviews({
  #             owner: context.repo.owner,
  #             repo: context.repo.repo,
  #             pull_number: context.payload.pull_request.number,
  #           });
  #           const approved = reviews.some(r => r.state === "APPROVED");
  #           if (!approved) core.setFailed("âŒ PR sem aprovaÃ§Ã£o. Deploy bloqueado.");

  deploy:
    name: Deploy
    # needs: check-approvals
    runs-on: ${{ fromJSON(inputs.runner_labels) }}
    environment: ${{ inputs.environment_name }}
    
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Login no Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ vars.ORG_REGISTRY_URL }}
          username: ${{ secrets.REGISTRY_USERNAME }}
          password: ${{ secrets.REGISTRY_PASSWORD }}

      # --- MUDANÃ‡A PRINCIPAL: CONSTRUÃ‡ÃƒO GRANULAR DO .ENV ---
      - name: Gerar .env DinÃ¢mico
        working-directory: ${{ inputs.working_directory }}
        run: |
          # Limpa arquivo anterior se existir
          rm -f .env
          touch .env

          echo "--- Gerando configuraÃ§Ãµes de ambiente ---"
          if [ "${{ inputs.project_type }}" == "backend" ]; then
            echo "API_ROOT_PATH=${{ vars.API_ROOT_PATH }}" >> .env
            echo "API_V1_STR=${{ vars.API_V1_STR }}" >> .env
            echo "AUTH_SERVICE_URL=${{ vars.AUTH_SERVICE_URL }}" >> .env
            echo "TIPO_AMBIENTE=${{ vars.TIPO_AMBIENTE }}" >> .env
            echo "TITLE=${{ vars.TITLE }}" >> .env
            
            echo "LOG_LEVEL=info" >> .env 

            # 2. Segredos (Repository Secrets - Criptografados)
            echo "PROD_DB_HOST=${{ secrets.PROD_DB_HOST }}" >> .env
            echo "PROD_DB_PORT=${{ secrets.PROD_DB_PORT }}" >> .env
            echo "PROD_DB_NAME=${{ secrets.PROD_DB_NAME }}" >> .env
            echo "PROD_DB_USER=${{ secrets.PROD_DB_USER }}" >> .env
            echo "PROD_DB_PASSWORD=${{ secrets.PROD_DB_PASSWORD }}" >> .env
            echo "PROD_LOG_LEVEL=${{ secrets.PROD_LOG_LEVEL }}" >> .env
            echo "PROD_RELOAD=${{ secrets.PROD_RELOAD }}" >> .env
            
            echo "JWT_SECRET=${{ secrets.JWT_SECRET }}" >> .env
            
            echo "MAIL_USERNAME=${{ secrets.MAIL_USERNAME }}" >> .env
            echo "MAIL_PASSWORD=${{ secrets.MAIL_PASSWORD }}" >> .env
            echo "MAIL_FROM=${{ secrets.MAIL_FROM }}" >> .env
          else
            echo "NEXT_PUBLIC_API_URL=${{ vars.AUTH_SERVICE_URL }}" >> .env
            echo "NEXT_PUBLIC_URL=${{ vars.NEXT_PUBLIC_URL }}" >> .env
            echo "NEXT_PUBLIC_BASE_PATH=${{ vars.API_ROOT_PATH }}" >> .env
            echo "NEXT_PUBLIC_FEATURE_FLAGS_ENABLED=${{ vars.FEATURE_FLAGS_ENABLED }}" >> .env
            echo "NEXT_PUBLIC_PORTAL_BASE_URL=${{ vars.PORTAL_BASE_URL }}" >> .env
            echo "NEXT_PUBLIC_TITLE=${{ vars.TITLE }}" >> .env
          fi

          cat .env

      - name: Atualizar ServiÃ§o
        working-directory: ${{ inputs.working_directory }}
        env:
          NETWORK_NAME: ${{ vars.NETWORK_NAME }}
          # Recalculando a TAG baseada no SHA atual
          IMAGE_TAG: ${{ vars.ORG_REGISTRY_URL }}/${{ vars.REPO_IMAGE_NAME }}:${{ github.event.pull_request.head.sha || github.sha }}
        run: |
          echo "ðŸš€ Baixando imagem: $IMAGE_TAG"
          docker compose pull ${{ inputs.service_name }}

          echo "ðŸš€ Recriando container..."
          docker compose up -d ${{ inputs.service_name }}

      - name: Limpeza
        if: always()
        run: docker image prune -f
